"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[367],{94392:e=>{e.exports=JSON.parse('{"functions":[{"name":"add","desc":"Adds a new [Service] to [Conductor].\\n:::tip\\nIt\'s recommended to use `script.Name` as your service name.\\n:::","params":[{"name":"serviceName","desc":"","lua_type":"string"},{"name":"service","desc":"","lua_type":"Service"}],"returns":[],"function_type":"static","source":{"line":86,"path":"packages/conductor/init.lua"}},{"name":"get","desc":":::caution\\nThis method will yield until [Conductor.start] is called and all services have initialized. Using it in a [Service] during initialization may cause an infinite yield!\\n:::","params":[{"name":"serviceName","desc":"","lua_type":"string"}],"returns":[{"desc":"","lua_type":"Service\\n"}],"function_type":"static","yields":true,"source":{"line":98,"path":"packages/conductor/init.lua"}},{"name":"start","desc":"Runs all of the service life cycle methods and makes them accessible via [Conductor.get]. Set the `verbose` parameter to `true` to print a message as each service is started.\\n:::caution\\nOnce this method has been called, you will not longer be able to [add new services](#add)!\\n:::","params":[{"name":"verbose","desc":"","lua_type":"boolean?"}],"returns":[{"desc":"","lua_type":"nil\\n"}],"function_type":"static","source":{"line":113,"path":"packages/conductor/init.lua"}}],"properties":[],"types":[{"name":"Service","desc":"Services are essentially just tables with two optional life cycle methods: `OnInit` and `OnStart`.\\n\\n`OnInit` is called when [Conductor.start] is called and services cannot be accessed until all services have finished running `OnInit`. Then `OnStart` will be called in parallel for all services and access to services will be available.\\n\\n:::tip\\nIf you do not need either life cycle method, it is recommended you use a standard module instead of a service.\\n:::","fields":[{"name":"OnInit","lua_type":"(Service) -> () | nil","desc":""},{"name":"OnStart","lua_type":"(Service) -> () | nil","desc":""},{"name":"...","lua_type":"any","desc":""}],"source":{"line":74,"path":"packages/conductor/init.lua"}}],"name":"Conductor","desc":"`Conductor = \\"minstrix/conductor@^0.1\\"`\\n\\nConductor allows you to create and orchestrate services. Read the [Service] interface for more information.\\n\\n```lua\\n-- In ServiceA.lua\\n\\nlocal ServiceA = {}\\n\\nfunction ServiceA:OnInit()\\n    print(\\"Initialized!\\")\\n    self.SomeVariable = \\"Some string\\"\\nend\\n\\nfunction ServiceA:OnStart()\\n    print(\\"Started!\\")\\nend\\n\\nfunction ServiceA:SomeMethod()\\n    print(self.SomeVariable)\\nend\\n\\nConductor.add(\\"ServiceA\\", ServiceA)\\n\\n-- In ServiceB.lua\\n\\nlocal ServiceB = {}\\n\\nfunction ServiceB:OnInit()\\n    print(\\"Initialized!\\")\\nend\\n\\nfunction ServiceB:OnStart()\\n    print(\\"Started!\\")\\n\\n    local ServiceA = Conductor.get(\\"ServiceA\\")\\n    ServiceA:SomeMethod() --\x3e \\"Some string\\"\\nend\\n\\nConductor.add(\\"ServiceB\\", ServiceB)\\n\\n-- In a script\\n\\nConductor.start()\\n```","source":{"line":49,"path":"packages/conductor/init.lua"}}')}}]);