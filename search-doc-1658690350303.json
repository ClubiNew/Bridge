[{"title":"Ancestor","type":0,"sectionRef":"#","url":"api/Ancestor","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"Ancestor","url":"api/Ancestor#functions","content":" "},{"title":"new​","type":1,"pageTitle":"Ancestor","url":"api/Ancestor#new","content":"&lt;/&gt; Ancestor.new(object: any) → Ancestor Wraps the object in an Ancestor class. You can then index children and properties or call methods on the object or it's children that may be nil without throwing errors.  "},{"title":"Or​","type":1,"pageTitle":"Ancestor","url":"api/Ancestor#Or","content":"&lt;/&gt; Ancestor:Or(default: any) → any Unwraps and returns the object, or the provided default if the object is nil.  "},{"title":"IfNil​","type":1,"pageTitle":"Ancestor","url":"api/Ancestor#IfNil","content":"&lt;/&gt; Ancestor:IfNil(func: () → ()) → Ancestor Calls the provided function if the unwrapped object is nil and returns the wrapper for chain calls.  "},{"title":"IfNotNil​","type":1,"pageTitle":"Ancestor","url":"api/Ancestor#IfNotNil","content":"&lt;/&gt; Ancestor:IfNotNil(func: (any) → ()) → Ancestor Calls the provided function with the unwrapped object if it is not nil and returns the wrapper for chain calls. "},{"title":"Bridge","type":0,"sectionRef":"#","url":"api/Bridge","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Bridge","url":"api/Bridge#types","content":" "},{"title":"Bridge​","type":1,"pageTitle":"Bridge","url":"api/Bridge#Bridge","content":"&lt;/&gt; interface Bridge { Events: {string: RemoteEvent } addMethod: ( string, (any) → (any) ) → MethodConstructor } A bridge is used to allow for communication between the client and server. Bridges are made using Bridge.blueprint which will automatically create the Events array based on the given Blueprint. You can then add methods to the Bridge using the addMethod function and once all methods have been added, you can construct the Bridge. Clients will then be able to request the bridge and call the methods or listen to the events on it. note The intention is that Events are fired by the server, but the server can also listen for events being fired by clients if a response is not necessary. tip Once the Bridge is constructed, all of the methods added with addMethod will be added to the Bridge's table. This means that methods can call each other, just be aware that there will be no inbound/outbound processing between methods.  "},{"title":"Processor​","type":1,"pageTitle":"Bridge","url":"api/Bridge#Processor","content":"&lt;/&gt; type Processor = (any) → (any) A processor is a function that is called either before or after a Bridge method is called by the client, with the arguments passed to or returned by the method or previous processor. Processors can either return a tuple of arguments to be used by the method and/or following processor(s), or throw an error to halt the request. You can add processors to a Bridge in the Blueprint, or add them to specific methods on a Bridge using a MethodConstructor. tip Processors will be called in the order they appear in the inbound/outbound arrays. Be mindful that processors return the arguments expected by the next processor(s) in the array. caution Processors are not used for connections to a RemoteEvent in the Events array of the Bridge.  "},{"title":"Blueprint​","type":1,"pageTitle":"Bridge","url":"api/Bridge#Blueprint","content":"&lt;/&gt; interface Blueprint { name: string events: {string} inboundProcessors: {Processor} outboundProcessors: {Processor} } A blueprint is used to define a Bridge when calling the [blueprint] method. Read the Processor interface for more information on the inbound/outbound processor arrays. tip It's recommended to use script.Name as the name. caution Blueprint inbound processors will always run before inbound processors added to a MethodConstructor, and Blueprint outbound processors will always run after outbound processors added to a MethodConstructor.  "},{"title":"MethodConstructor​","type":1,"pageTitle":"Bridge","url":"api/Bridge#MethodConstructor","content":"&lt;/&gt; interface MethodConstructor { withInboundProcessors: ({Processor}) → MethodConstructor withOutboundProcessors: ({Processor}) → MethodConstructor } A method constructor is returned when addMethod is called on an un-constructed Bridge. You can then use the withInboundProcessors and withOutboundProcessors functions to add processors to that method without adding them to the whole Bridge. Read the Processor interface for more information. caution Method-specific processors will always run after the Blueprint inbound processors and before the outbound Blueprint processors. "},{"title":"Functions​","type":1,"pageTitle":"Bridge","url":"api/Bridge#functions","content":" "},{"title":"blueprint​","type":1,"pageTitle":"Bridge","url":"api/Bridge#blueprint","content":"This item only works when running on the server. Server &lt;/&gt; Bridge.blueprint(blueprint: Blueprint) → Bridge   "},{"title":"construct​","type":1,"pageTitle":"Bridge","url":"api/Bridge#construct","content":"This item only works when running on the server. Server &lt;/&gt; Bridge.construct(bridge: Bridge) → () Adds the methods to the given Bridge and internally creates a RemoteFunction for each, making the Bridge available to the client. caution Once a Bridge has been constructed, you can no longer add new methods to it.  "},{"title":"to​","type":1,"pageTitle":"Bridge","url":"api/Bridge#to","content":"This item only works when running on the client. Client This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Bridge.to(bridgeName: string) → ()  tip This method will yield until the requested Bridge is constructed. After every 30 seconds of yielding, a warning will be printed to notify you if something isn't constructing correctly. "},{"title":"Array","type":0,"sectionRef":"#","url":"api/Array","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"Array","url":"api/Array#functions","content":" "},{"title":"first​","type":1,"pageTitle":"Array","url":"api/Array#first","content":"override &lt;/&gt; Array.first( array: {T}, filter: ( index: number, value: T ) → boolean ) → ( number, T ) Returns the index and value of the first element in the array that returns true when passed to the given filter function.  "},{"title":"filter​","type":1,"pageTitle":"Array","url":"api/Array#filter","content":"override &lt;/&gt; Array.filter( array: {T}, filter: ( index: number, value: T ) → boolean ) → {T} Returns a new array consisting only of elements that return true when passed to the provided filter function. caution Valid values will be added to the end of the new array to preserve the consecutive integer keys. This means that the values are not guarantee to have the same keys after filtering. If you need to preserve the keys but not the array structure, use Table.filter.  "},{"title":"range​","type":1,"pageTitle":"Array","url":"api/Array#range","content":"&lt;/&gt; Array.range( array: {T}, numElements: number, fromIndex: number?-- defaults to 1 ) → {T} Returns a new array consisting of numElements values from the given array, starting at fromIndex.  "},{"title":"slice​","type":1,"pageTitle":"Array","url":"api/Array#slice","content":"&lt;/&gt; Array.slice( array: {T}, numElements: number, fromIndex: number?-- defaults to 1 ) → {T} Removes numElements values from the given array, starting at fromIndex, and returns them. caution Unlike other methods, Array.slice will mutate the given array.  "},{"title":"foldr​","type":1,"pageTitle":"Array","url":"api/Array#foldr","content":"&lt;/&gt; Array.foldr( array: {T}, initialValue: any, reduce: ( accumulator: any, index: number, value: T ) → any ) → any Short for &quot;fold right&quot;, performs the same function as Table.reduce but begins at index 1 and counts upwards to #array.  "},{"title":"foldl​","type":1,"pageTitle":"Array","url":"api/Array#foldl","content":"&lt;/&gt; Array.foldl( array: {T}, initialValue: any, reduce: ( accumulator: any, index: number, value: T ) → any ) → any Short for &quot;fold left&quot;, performs the same function as Table.reduce but begins at index #array and counts down to 1.  "},{"title":"reverse​","type":1,"pageTitle":"Array","url":"api/Array#reverse","content":"&lt;/&gt; Array.reverse(array: {T}) → {T} Returns a new array consisting of the values of the given array, in reverse order.  "},{"title":"random​","type":1,"pageTitle":"Array","url":"api/Array#random","content":"override &lt;/&gt; Array.random(array: {T}) → ( number, T ) Selects a random element from the given array and returns it's index and value.  "},{"title":"randomWeighted​","type":1,"pageTitle":"Array","url":"api/Array#randomWeighted","content":"override &lt;/&gt; Array.randomWeighted( array: {T}, weight: function(index: number,value: T) → integer&gt;=1 ) → ( number, T ) Calls the given weight function on each element to determine it's weight, and then selects a random element based on the weights and returns it's index and value. tip It is recommended that the weight function's return be the number of &quot;standard&quot; elements that element is &quot;worth&quot;.  "},{"title":"shuffle​","type":1,"pageTitle":"Array","url":"api/Array#shuffle","content":"&lt;/&gt; Array.shuffle(array: {T}) → {T} Shuffles the given array into a new array.  "},{"title":"flatten​","type":1,"pageTitle":"Array","url":"api/Array#flatten","content":"&lt;/&gt; Array.flatten( array: {any}, deep: boolean?-- defaults to false, will recursively flatten sub-arrays if true ) → {any} Flattens an array of tables into a single array. local matrix = { {1, 2, 3}, {4, 5, 6}, {7, 8, 9}, } local flattenedArray = Array.flatten(matrix) print(flattenedArray) --&gt; {1, 2, 3, 4, 5, 6, 7, 8, 9}  "},{"title":"Hooks","type":0,"sectionRef":"#","url":"api/Hooks","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Hooks","url":"api/Hooks#types","content":" "},{"title":"Hook​","type":1,"pageTitle":"Hooks","url":"api/Hooks#Hook","content":"&lt;/&gt; interface Hook { Attach: (Hook) → () Janitor: Janitor Instance: Instance ...: any } Hooks are used to bind to CollectionService tags. When the tag specified in Hooks.add is added to an instance, a new copy of the Hook is created, the Instance and Janitor properties are set, and the Attach method is called. When the instance is removed, the Janitor's clean-up method will be called. See the Janitor docs for more information on using Janitors. "},{"title":"Functions​","type":1,"pageTitle":"Hooks","url":"api/Hooks#functions","content":" "},{"title":"add​","type":1,"pageTitle":"Hooks","url":"api/Hooks#add","content":"&lt;/&gt; Hooks.add( collectionTag: string, hook: Hook ) → () Attaches the provided hook to the given CollectionService tag. tip It's recommended to use script.Name as your collection tag. "},{"title":"Conductor","type":0,"sectionRef":"#","url":"api/Conductor","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Conductor","url":"api/Conductor#types","content":" "},{"title":"Service​","type":1,"pageTitle":"Conductor","url":"api/Conductor#Service","content":"&lt;/&gt; interface Service { OnInit: (Service) → () | nil OnStart: (Service) → () | nil ...: any } Services are essentially just tables with two optional life cycle methods: OnInit and OnStart. OnInit is called when Conductor.start is called and services cannot be accessed until all services have finished running OnInit. Then OnStart will be called in parallel for all services and access to services will be available. tip If you do not need either life cycle method, it is recommended you use a standard module instead of a service. "},{"title":"Functions​","type":1,"pageTitle":"Conductor","url":"api/Conductor#functions","content":" "},{"title":"add​","type":1,"pageTitle":"Conductor","url":"api/Conductor#add","content":"&lt;/&gt; Conductor.add( serviceName: string, service: Service ) → () Adds a new Service to Conductor. tip It's recommended to use script.Name as your service name.  "},{"title":"get​","type":1,"pageTitle":"Conductor","url":"api/Conductor#get","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Conductor.get(serviceName: string) → Service  caution This method will yield until Conductor.start is called and all services have initialized. Using it in a Service during initialization may cause an infinite yield!  "},{"title":"start​","type":1,"pageTitle":"Conductor","url":"api/Conductor#start","content":"&lt;/&gt; Conductor.start(verbose: boolean?) → nil Runs all of the service life cycle methods and makes them accessible via Conductor.get. Set the verbose parameter to true to print a message as each service is started. caution Once this method has been called, you will not longer be able to add new services! "},{"title":"Attributions","type":0,"sectionRef":"#","url":"docs/attributions","content":"Attributions My main motivation for releasing these modules was sleitnick's RbxUtils. Some of the packages within this repository make use of them, and I would strongly recommend checking out that collection as well if you need anything that isn't here. You can see the full list of third-party packages used by checking the wally.toml file for each module.","keywords":""},{"title":"Installation","type":0,"sectionRef":"#","url":"docs/installation","content":"Installation The intended installation workflow is to install the modules you need using Wally packages and then synchronize the files into Roblox Studio using a tool like Rojo. The Wally dependency for each package can be found at the top of the API page for that module. Packages are versioned using the Semantic Versioning system and you can see a full list of available versions by running wally search minstrix/package-name. It's always recommended that you use the most recent patch for your selected major/minor version to ensure you avoid any bugs. If you are unable to use Wally + Rojo, you can also manually copy &amp; paste the code from the GitHub repository directly into module scripts in Roblox Studio.","keywords":""},{"title":"About","type":0,"sectionRef":"#","url":"docs/intro","content":"About RbxPackages is a collection of utility modules designed for use by Roblox Developers. To get started, check out the installation instructions and look through the module documentation in the API tab. I anticipate this to be a fairly small project so at the moment there is no Discord server setup. If you have any questions feel free to reach out to me in the Roblox OSS Community Discord or send an email to minstrix@mindblast.games and I would be happy to help.","keywords":""},{"title":"Table","type":0,"sectionRef":"#","url":"api/Table","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Table","url":"api/Table#properties","content":" "},{"title":"Array​","type":1,"pageTitle":"Table","url":"api/Table#Array","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; Table.Array: Array A collection of functions specifically for array tables. "},{"title":"Functions​","type":1,"pageTitle":"Table","url":"api/Table#functions","content":" "},{"title":"first​","type":1,"pageTitle":"Table","url":"api/Table#first","content":"&lt;/&gt; Table.first( tbl: {[K]: V}, filter: ( key: K, value: V ) → boolean ) → ( K, V ) Returns a key/value pair from the given table that returns true when passed to the provided filter function.  "},{"title":"filter​","type":1,"pageTitle":"Table","url":"api/Table#filter","content":"&lt;/&gt; Table.filter( tbl: {[K]: V}, filter: ( key: K, value: V ) → boolean ) → {[K]: V} Returns a new table without key/value pairs that return false when passed to the given filter function.  "},{"title":"map​","type":1,"pageTitle":"Table","url":"api/Table#map","content":"&lt;/&gt; Table.map( tbl: {[K]: V}, map: ( key: K, value: V ) → any ) → {[K]: any} Returns a new table where newTable[key] = map(key, oldTable[key]).  "},{"title":"reduce​","type":1,"pageTitle":"Table","url":"api/Table#reduce","content":"&lt;/&gt; Table.reduce( tbl: {[K]: V}, initialValue: any, reduce: ( accumulator: any, key: K, value: V ) → any ) → any-- the result of the final function call Calls the provided function for each element of a table with the previous result and the current element as arguments, starting with the initialValue as the previous result. local sum = Table.reduce({1, 2, 3}, 0, function(accumulator, index, value) return accumulator + value end) print(sum) --&gt; 6   "},{"title":"sum​","type":1,"pageTitle":"Table","url":"api/Table#sum","content":"&lt;/&gt; Table.sum(tbl: {[any]: number}) → number Returns the sum of the values in the given table.  "},{"title":"max​","type":1,"pageTitle":"Table","url":"api/Table#max","content":"&lt;/&gt; Table.max(tbl: {[any]: number}) → number? Returns the maximum value in the given table, or nil if the table is empty.  "},{"title":"min​","type":1,"pageTitle":"Table","url":"api/Table#min","content":"&lt;/&gt; Table.min(tbl: {[any]: number}) → number? Returns the minimum value in the given table, or nil if the table is empty.  "},{"title":"clone​","type":1,"pageTitle":"Table","url":"api/Table#clone","content":"&lt;/&gt; Table.clone( tbl: table, deep: boolean?-- defaults to false, will recursively clone sub-tables if true ) → table Clones the key/value pairs of the given table into a new table.  "},{"title":"pairs​","type":1,"pageTitle":"Table","url":"api/Table#pairs","content":"&lt;/&gt; Table.pairs(tbl: {[K]: V}) → {{ key: K, value: V }} Returns the key/value pairs of the given table.  "},{"title":"keys​","type":1,"pageTitle":"Table","url":"api/Table#keys","content":"&lt;/&gt; Table.keys(tbl: {[T]: any}) → {T} Returns an array of the given table's keys.  "},{"title":"values​","type":1,"pageTitle":"Table","url":"api/Table#values","content":"&lt;/&gt; Table.values(tbl: {[any]: T}) → {T} Returns an array of the given table's values. caution When called on a non-array table, this will return an array table. When called on a table that is already an array, the returned table will have the same keys, but values may be at different indices than they previously were.  "},{"title":"all​","type":1,"pageTitle":"Table","url":"api/Table#all","content":"&lt;/&gt; Table.all( tbl: table, filter: ( key: any, value: any ) → boolean ) → boolean Returns true if all elements return true when passed to the provided filter function.  "},{"title":"random​","type":1,"pageTitle":"Table","url":"api/Table#random","content":"&lt;/&gt; Table.random(tbl: {[K]: V}) → ( K, V ) Behaves the same as Array.random, but for non-array tables with potentially non-numeric keys.  "},{"title":"randomWeighted​","type":1,"pageTitle":"Table","url":"api/Table#randomWeighted","content":"&lt;/&gt; Table.randomWeighted( tbl: {[K]: V}, weight: ( key: K, value: V ) → number ) → ( K, V ) Behaves the same as Array.randomWeighted, but for non-array tables with potentially non-numeric keys. "}]