[{"title":"Bridge","type":0,"sectionRef":"#","url":"api/Bridge","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Bridge","url":"api/Bridge#properties","content":" "},{"title":"Middleware​","type":1,"pageTitle":"Bridge","url":"api/Bridge#Middleware","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; Bridge.Middleware: MiddlewareManager   "},{"title":"Services​","type":1,"pageTitle":"Bridge","url":"api/Bridge#Services","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; Bridge.Services: ServiceManager   "},{"title":"Hooks​","type":1,"pageTitle":"Bridge","url":"api/Bridge#Hooks","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; Bridge.Hooks: HookManager   "},{"title":"Utilities​","type":1,"pageTitle":"Bridge","url":"api/Bridge#Utilities","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; Bridge.Utilities: Utilities  "},{"title":"HookManager","type":0,"sectionRef":"#","url":"api/HookManager","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"HookManager","url":"api/HookManager#types","content":" "},{"title":"Hook​","type":1,"pageTitle":"HookManager","url":"api/HookManager#Hook","content":"&lt;/&gt; interface Hook { Attach: (Hook) → () Janitor: Janitor Instance: Instance ...: any } Hooks are used to bind to CollectionService tags. When the tag specified in HookManager.add() is added to an instance, a new copy of the Hook is created, the Instance and Janitor properties are set, and the Attach method is called. When the instance is removed, the Janitor's clean-up method will be called. See the Janitor docs for more information on using Janitors. "},{"title":"Functions​","type":1,"pageTitle":"HookManager","url":"api/HookManager#functions","content":" "},{"title":"add​","type":1,"pageTitle":"HookManager","url":"api/HookManager#add","content":"&lt;/&gt; HookManager.add( collectionTag: string, hook: Hook ) → () Adds a new hook for the provided class and CollectionService tag. note It is recommended that you use script.Name as your collection tag. "},{"title":"ServiceManager","type":0,"sectionRef":"#","url":"api/ServiceManager","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"ServiceManager","url":"api/ServiceManager#types","content":" "},{"title":"Service​","type":1,"pageTitle":"ServiceManager","url":"api/ServiceManager#Service","content":"&lt;/&gt; interface Service { OnInit: (Service) → () | nil OnStart: (Service) → () | nil ...: any } Services are essentially just tables with two optional life cycle methods. As such, you can store anything in them that could go in a normal table. note If you do not need either life cycle method, it is recommended you use a standard module instead of a service. "},{"title":"Functions​","type":1,"pageTitle":"ServiceManager","url":"api/ServiceManager#functions","content":" "},{"title":"add​","type":1,"pageTitle":"ServiceManager","url":"api/ServiceManager#add","content":"&lt;/&gt; ServiceManager.add( serviceName: string, service: Service ) → ()  note It is recommended that you use script.Name as your service name.  "},{"title":"get​","type":1,"pageTitle":"ServiceManager","url":"api/ServiceManager#get","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; ServiceManager.get(serviceName: string) → Service  caution This method will yield until ServiceManager.start() is called and services have initialized. Using it in a service during initialization may cause an infinite yield!  "},{"title":"start​","type":1,"pageTitle":"ServiceManager","url":"api/ServiceManager#start","content":"&lt;/&gt; ServiceManager.start(verbose: boolean?) → () Runs all of the service life cycle methods and makes them accessible via ServiceManager.get(). Set the verbose parameter to true to print a message as each service is started. caution Once this method has been called, you will not longer be able to add new services! "},{"title":"Utilities","type":0,"sectionRef":"#","url":"api/Utilities","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Utilities","url":"api/Utilities#properties","content":" "},{"title":"Signal​","type":1,"pageTitle":"Utilities","url":"api/Utilities#Signal","content":"&lt;/&gt; Utilities.Signal: Signal See the Signal documentation here.  "},{"title":"Janitor​","type":1,"pageTitle":"Utilities","url":"api/Utilities#Janitor","content":"&lt;/&gt; Utilities.Janitor: Janitor See the Janitor documentation here. "},{"title":"Installation","type":0,"sectionRef":"#","url":"docs/installation","content":"Installation To install Bridge, you'll need to setup Wally and add Bridge = &quot;minstrix/bridge@^0.2&quot; to your dependencies.","keywords":""},{"title":"About","type":0,"sectionRef":"#","url":"docs/intro","content":"About Bridge is a Roblox game framework. It has three main features; hooks, services, and middleware. Hooks are used to bind modules to collection service tags. Services are used for easy life cycles and inter-script communication. Middleware is used to simplify client-server remotes. You can read more about how each of these work by viewing their respective API pages.","keywords":""},{"title":"MiddlewareManager","type":0,"sectionRef":"#","url":"api/MiddlewareManager","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"MiddlewareManager","url":"api/MiddlewareManager#types","content":" "},{"title":"Middleware​","type":1,"pageTitle":"MiddlewareManager","url":"api/MiddlewareManager#Middleware","content":"&lt;/&gt; interface Middleware { Events: {string: RemoteEvent } ...: ( Middleware, any ) → (any) } Middleware is used to allow for communication between the client and server. Servers create the middleware and define events and functions, and then clients request the middleware and make calls to the functions and listen to the events. note Servers can also listen for calls from clients to the events if a response is not necessary, but no inbound/outbound processing will take place.  "},{"title":"MiddlewareOptions​","type":1,"pageTitle":"MiddlewareManager","url":"api/MiddlewareManager#MiddlewareOptions","content":"&lt;/&gt; interface MiddlewareOptions { inboundProcessors: {(...) → (...)} | nil outboundProcessors: {(...) → (...)} | nil events: {string} | nil } The functions in the inboundProcessors table will be called in order before middleware functions are called. Likewise, the functions in the outboundProcessors table will be called in order before returning data to the client. In each function, you can either throw an error to stop the request from going through, or return the arguments with any modifications for the next processor to use. Each string in the events table will be turned into a RemoteEvent in the Middleware. caution Processors are bypassed when listening for client calls to the remote events. "},{"title":"Functions​","type":1,"pageTitle":"MiddlewareManager","url":"api/MiddlewareManager#functions","content":" "},{"title":"new​","type":1,"pageTitle":"MiddlewareManager","url":"api/MiddlewareManager#new","content":"This item only works when running on the server. Server &lt;/&gt; MiddlewareManager.new( middlewareName: string, middlewareOptions: MiddlewareOptions ) → Middleware  note It is recommended that you use script.Name as your middleware name.  "},{"title":"add​","type":1,"pageTitle":"MiddlewareManager","url":"api/MiddlewareManager#add","content":"This item only works when running on the server. Server &lt;/&gt; MiddlewareManager.add(middleware: Middleware) → ()  caution Once middleware has been added to the middleware manager, you can no longer add new methods to it.  "},{"title":"get​","type":1,"pageTitle":"MiddlewareManager","url":"api/MiddlewareManager#get","content":"This item only works when running on the client. Client This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; MiddlewareManager.get(middlewareName: string) → Middleware  caution This method will yield until the requested Middleware is added to the middleware manager. After every 30 seconds of yielding, a warning will be output so you can see which middle wares aren't added correctly. "},{"title":"Memory Tracking","type":0,"sectionRef":"#","url":"docs/memory","content":"Memory Tracking Bridge sets debugger memory categories so that you can track down memory leaks in your code. Before calling the :OnInit() and :OnStart() methods of services, the memory category will be set to NAME_Init or NAME_Start respectively, where NAME is the service name. This means you can easily and accurately determine memory usage for a service by opening the developer console, navigating to the memory tab, selecting client or server, and then searching the name of your service.","keywords":""}]